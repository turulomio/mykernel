#!/usr/bin/python3
import datetime, os, argparse, sys

def version():
    if os.path.exists("/usr/src/linux/Makefile"):
       f=open("/usr/src/linux/Makefile")
       f.readline()
       version=f.readline().split(" = ")[1].strip()
       subversion=f.readline().split(" = ")[1].strip()
       subsubversion=f.readline().split(" = ")[1].strip()
       subsubsubversion=f.readline().split(" = ")[1].strip()
       s="{}.{}.{}{}".format(version,subversion,subsubversion,subsubsubversion)
       print ("Version detected: {}".format(s))
    else:
       print ("Version not detected")
       sys.exit(255)
    return s

def s(command):
    os.system(command)

def ldd(program):
   """Function that gets a program or lib and gets all shared dependencies.
      They are added to saved set"""
   for line in os.popen("ldd -v {}".format(program)):
      if line.find("no es un ejecutable")>=0:
         return
      if line.find("Version information")>0:
         continue
      if line.find(":")>0:
         dep=line.strip().split(":")[0]
         if dep not in (saved):
            saved.add(dep)
###########################

dt=str(datetime.datetime.now()).split(".")[0].replace("-","").replace(" ","").replace(":","")
output="/tmp/myinit-{}/".format(dt)

parser=argparse.ArgumentParser("Initramfs generator for luks root partition")
parser.add_argument('-e', '--encrypted', help='Where encrypted device is', default='/dev/nvme0n1p2')
args=parser.parse_args()

saved=set(["/bin/sh", "/bin/echo", "/bin/mount", "/bin/umount","/sbin/cryptsetup", "/sbin/fsck.ext4","/sbin/switch_root"])
saved.add("/lib64/ld-linux-x86-64.so.2")#Si falla comand unknown serÃ¡ por este

vers=version()
lastsetcount=0

initfile="""#!/bin/sh

mount -t devtmpfs none /dev
mount -t proc proc /proc
mount -t sysfs sysfs /sys

echo 0 > /proc/sys/kernel/printk

cryptsetup luksOpen {0} root
fsck.ext4 /dev/mapper/root
mount /dev/mapper/root /newroot

umount /proc
umount /sys

if [[ -x "/newroot/sbin/init" ]] ; then
        exec switch_root /newroot /sbin/init
fi

echo "Failed to init Gentoo..."
""".format(args.encrypted)

s("rm -Rf {}".format(output))
s("mkdir {}".format(output))

os.chdir(output)

#Make dirs
for d in ["bin", "dev","etc", "lib64", "newroot", "proc", "sbin", "sys","usr/bin","usr/lib64"]:
   s("mkdir -p {}/{}".format(output,d))
s("ln -s lib64 lib")
os.chdir(output+"/usr/")
s("ln -s lib64 lib")
os.chdir(output)
s("cp -a /dev/null /dev/console /dev/tty {} {}/dev/".format(args.encrypted, output))

#Create init file
f=open("{}/init".format(output),"w")
f.write(initfile)
f.close()
s("chmod 777 init")

#Search recursively dependencies
while lastsetcount!=len(saved):
   tmp=set(saved)
   lastsetcount=len(saved)
   for p in tmp:
      ldd(p)

#Copy files
for f in saved:
   s("cp  {0} {1}{0}".format(f, output))
   saved.add("{}".format(f))

#Create timestamp
s("touch '{}/{}.txt'".format(output,datetime.datetime.now()))

## Genera el fichero
s("find . -print0 | cpio --null -o --format=newc > /tmp/myinit.cpio".format(output))#Cuidado no generarlo en el mismo sitio se grew
s("cat /tmp/myinit.cpio > /boot/initramfs-{}.img".format(vers))
